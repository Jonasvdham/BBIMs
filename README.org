#+TITLE: BBIMS
#+AUTHOR: Jonas van der Ham | MSc MADE
#+EMAIL: Jonasvdham@gmail.com
#+DATE: Tuesday, 25 July 2023
#+STARTUP: showall
#+PROPERTY: header-args :exports both :session bbims :cache no
:PROPERTIES:
#+OPTIONS: ^:nil
#+LATEX_COMPILER: xelatex
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [logo, color, author]
#+LATEX_HEADER: \insertauthor
#+LATEX_HEADER: \usepackage{minted}
#+LATEX_HEADER: \usepackage[style=ieee, citestyle=numeric-comp, isbn=false]{biblatex}
#+LATEX_HEADER: \addbibresource{~/made/bibliography/references.bib}
#+LATEX_HEADER: \setminted{bgcolor=WhiteSmoke}
#+OPTIONS: toc:nil
:END:

Thesis research project into the carbon-removal potential of bio-based
insulation materials (BBIMs)

[[file:DLCA.py]] models global warming impact of different construction scenarios
through a dynamic life cycle assessment
[[file:make_dataset.py]] creates the required dynamic life cycle inventory

** DLCA

[[file:DLCA.py]]

*** Issue: Straw GWI_inst negative trail

From what I have explored so far the model seems correct. My explanation is as
follows:
The GWI(t) in year t is the sum over all years j=0 to j=t. For each of these
years we count the emissions up to that year and multiply them with the
necessary reduction factor (emissions from longer ago have a smaller
influence).
In the case of straw here, there is a huge negative set of emissions at the
start which results in these negative emissions being summed over for all the
rest of the years in GWI

**** Culprit

The definition of the atmospheric decay function from Hoxha e.a. (2020) is as
below. For large t, this function goes to a0Bern, which means that for large
timeframes, the original negative emissions in the straw case still contribute
20% - which is probably far from the true behaviour.

Need to find a better approximation of the atmospheric CO2 curve somewhere.

#+begin_src python
def C_CO2(t):
    return (
        a0Bern
        + aBern[0] * np.exp(-t / TauCO2[0])
        + aBern[1] * np.exp(-t / TauCO2[1])
        + aBern[2] * np.exp(-t / TauCO2[2])
    )
a0Bern = 0.217
aBern = [0.259, 0.338, 0.186]
TauCO2 = [172.9, 18.51, 1.186]

def exp3(tf=100):
    x = np.arange(tf)
    y1 = [C_CO2(i) for i in range(tf)]
    y2 = [C_CH4(i) for i in range(tf)]
    y3 = [C_N2O(i) for i in range(tf)]
    plt.plot(x, y1, label="CO2")
    plt.plot(x, y2, label="CH4")
    plt.plot(x, y3, label="N2O")
    plt.legend()
    plt.show()
    plt.close()
#+end_src

**** exploration

For straw, the trail of GWI_inst drops down from a small positive peak back to
negative. In it's limit it should go to 0. Let's explore what's going on.

Experiments to plot:
  #+begin_src python
def exp(
    materials=["straw"],
    building_scenario="normal",
    total_houses=150000,
    time_horizon=2050,
    timeframe=200,
    plottype="inst",
    outfile=False,
):
    GWIs = DLCA(
        materials, building_scenario, total_houses, time_horizon, timeframe
    )
    x = np.arange(timeframe) + 2023
    for material in materials:
        for ghg in GWIs["straw"][plottype]:
            plt.plot(x, GWIs[material][plottype][ghg], label=ghg)
    plt.xlabel("Years")
    plt.ylabel("Radiative forcing " + plottype)
    plt.legend()
    plt.title(f"Global warming Impact ({plottype}, {building_scenario})")
    plt.grid(True)

    plt.show()

    plt.close()


def exp2(timeframe=10):
    tmp = pd.DataFrame(
        np.zeros((timeframe, 4)), columns=["CO2", "CH4", "N2O", "CO"]
    )
    tmp.loc[0] = [1e6, 1e4, 2e3, 1e4]
    GWI_inst = GWI(tmp, timeframe)
    GWI_inst_tot = GWI_inst.sum(axis=1)
    GWI_cum = GWI_inst_tot.cumsum()
    x = np.arange(timeframe) + 2023
    for ghg in GWI_inst:
        plt.plot(x, GWI_inst[ghg], label=ghg)
    plt.legend()
    plt.show()
    plt.close()
#+end_src

  #+begin_src python
[C_CO2(i) for i in range(200)]
[C_CH4(i) for i in range(200)]
[C_N2O(i) for i in range(200)]
#+end_src

All of these seem sensible and correct.
Small part of a df showing the CO2 emissions and the GWI_inst shows the
problem:

| index |           CO2 |        CH4 |        N2O |         CO |          inst |
|-------+---------------+------------+------------+------------+---------------|
|     0 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -1.804726e-09 |
|     1 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -3.423677e-09 |
|     2 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -4.943615e-09 |
|     3 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -6.402801e-09 |
|     4 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -7.818577e-09 |
|     5 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -9.199240e-09 |
|    .. |            .. |         .. |         .. |         .. |            .. |
|    25 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -3.221558e-08 |
|    26 | -1.184444e+06 | 160.844444 | 292.257778 | 384.421644 | -3.320654e-08 |
|    27 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -3.238223e-08 |
|    28 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -3.173359e-08 |
|    29 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -3.117432e-08 |
|    30 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -3.066655e-08 |
|    31 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -3.019335e-08 |
|    32 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -2.974678e-08 |
|    33 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -2.932284e-08 |
|    34 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -2.891925e-08 |
|    .. |            .. |         .. |         .. |         .. |            .. |
|   100 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 |  5.505687e-09 |
|   101 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 |  6.365927e-09 |
|   102 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 |  5.406442e-09 |
|   103 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 |  4.602033e-09 |
|   104 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 |  3.890165e-09 |
|   105 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 |  3.242107e-09 |
|   106 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 |  2.643812e-09 |
|    .. |            .. |         .. |         .. |         .. |            .. |
|   195 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -6.958133e-09 |
|   196 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -6.969819e-09 |
|   197 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -6.981275e-09 |
|   198 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -6.992509e-09 |
|   199 |  0.000000e+00 |   0.000000 |   0.000000 |   0.000000 | -7.003529e-09 |

Even though there are no more emissions (negative nor positive), the radiative
forcing is going down to below zero - as if there were negative emissions.

Next step is to check if DCF works properly
  #+begin_src python
DCF(200)
#+end_src

** Make Dataset

[[file:make_dataset.py]]

*** EoL

**** Incineration

|-----+--------------+----------+----------+----------|
|     |          CO2 |      CH4 |      N2O |       CO |
|-----+--------------+----------+----------+----------|
|   0 |    25.627314 | 0.055009 | 0.099952 | 0.131472 |
|   1 | -1579.259733 | 0.000000 | 0.000000 | 0.000000 |
|   2 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|   3 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
| ... |          ... |      ... |      ... |      ... |
|  49 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|  50 |  1604.887047 | 0.055009 | 0.099952 | 0.131472 |
|  51 | -1579.259733 | 0.000000 | 0.000000 | 0.000000 |
|  52 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
| ... |          ... |      ... |      ... |      ... |
|  74 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|  75 |  1579.259733 | 0.000000 | 0.000000 | 0.000000 |
|  76 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
| ... |          ... |      ... |      ... |      ... |
|  99 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|-----+--------------+----------+----------+----------|


**** Anaerobic disgestation

|------+--------------+----------+----------+----------|
| year |          CO2 |      CH4 |      N2O |       CO |
|------+--------------+----------+----------+----------|
|    0 |    25.627314 | 0.055009 | 0.099952 | 0.131472 |
|    1 | -1579.259733 | 0.000000 | 0.000000 | 0.000000 |
|    2 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|    3 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|  ... |          ... |      ... |      ... |      ... |
|   49 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|   50 |   309.835420 | 2.890776 | 0.139512 | 0.247459 |
|   51 | -1579.259733 | 0.000000 | 0.000000 | 0.000000 |
|   52 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|  ... |          ... |      ... |      ... |      ... |
|   74 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|   75 |   284.208107 | 2.835767 | 0.039560 | 0.115987 |
|   76 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|  ... |          ... |      ... |      ... |      ... |
|   99 |     0.000000 | 0.000000 | 0.000000 | 0.000000 |
|------+--------------+----------+----------+----------|

*** CO2bio

Had previously removed this as all rotation periods were 1. If I take wood
fibre insulation back implement CO2bio like this:

  #+begin_src python
def CO2bio(material, insulation_per_year, timeframe):
    CO2bio_per_year = np.zeros(
        len(insulation_per_year) + MATERIALS[material]["rotation"]
    )
    for i, kg in enumerate(insulation_per_year):
        for j in range(MATERIALS[material]["rotation"]):
            CO2bio_per_year[i + j] += (
                kg
                * MATERIALS[material]["CO2bio"]
                / MATERIALS[material]["rotation"]
            )
    return CO2bio_per_year[:timeframe]
#+end_src

*** B/C/D

**** Module B

Model module B - replacement after functional lifetime.
  - In a dynamic model, module B should also be dynamic. I.e. start a whole new
    product lifecycle.
  - Can only be done after adding modules C & D

I can use copies of the dataset but only when I first have a dataset which for
each house models:
- construction
- waste spike after product lifetime
for each replacement.

Then at the end-of-life for the building add 1 more waste spike.

Example showing Edge case if building_lt % product_lt == 0:
- e.g. ceil(75 / 50) - 1 = 2  - 1 = 1 -> 1 replacement
- e.g. ceil(100 / 25) - 1 = 4 - 1 = 3 ->  3 replacements
- A replacement includes both module A and module C/D costs
- After building lifetime add EoL cost (only module C/D)


** Demo

housing scenarios
#+begin_src python
houses_per_year_slow(150000, 27)
houses_per_year_fast(150000, 27)
#+end_src

Large differences between cork / cellulose / stone wool
Francesco: cork is an 'anomaly' in the EcoInvent dataset, high production energy.
#+begin_src python
dataset = make_datasets()
dataset['cork']
dataset['stone wool']
dataset['cellulose']
#+end_src

Plotting them:
#+begin_src python
plot_GWI(['cork', 'cellulose', 'stone wool'], building_scenario='normal', plottype='inst')
plot_GWI(['cork', 'cellulose', 'stone wool'], building_scenario='normal', plottype='cum')
#+end_src

*** Plots

# Houses per year

#+begin_src python
def hpy(houses=150000, years=27, plottype="inst", outfile=False):
    if plottype == "inst":
        slow = houses_per_year_slow(houses, years)
        fast = houses_per_year_fast(houses, years)
        normal = [houses / years for i in range(years)]
        title = "Number of houses constructed per year"
        x = np.arange(years) + 2023
    else:
        slow = [(houses / (years ** 2)) * x ** 2 for x in range(years + 1)]
        fast = [(houses / (years ** 0.5)) * x ** 0.5 for x in range(years + 1)]
        normal = [i * houses / years for i in range(years + 1)]
        title = "Total number of houses constructed"
        x = np.arange(years + 1) + 2023
    plt.plot(x, slow, label="slow")
    plt.plot(x, fast, label="fast")
    plt.plot(x, normal, label="normal")
    plt.legend()
    plt.title(title)
    plt.grid(True)

    if outfile:
        plt.savefig(f"plots/houses_per_year.svg")
    else:
        plt.show()
    plt.close()

#+end_src
